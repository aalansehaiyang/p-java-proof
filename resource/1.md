##  sleep、wait、notify、notifyAll
----

### 方法说明

**wait()：**  当前线程进行wait等待状态，同时释放资源锁，其他正在等待该锁的线程开始抢占锁进而运行，当调用了notify() 方法，之前调用wait()的线程才会解除wait状态，有权重新去参与竞争同步资源锁，如果抢到锁可以继续执行。


**sleep()：**  方法正在执行的线程主动让出CPU（然后CPU就可以去执行其他任务），在sleep指定时间后CPU再回到该线程继续往下执行(注意：sleep方法只让出了CPU，而并不会释放同步资源锁)。

示例：

* proof.chapter1.TestWait
* proof.chapter1.TestNotifyAll



**wait与sleep 两者比较：**

* sleep()方法可以在任何地方使用；wait()方法则只能在同步方法或同步块中使用；

* sleep()是线程类（Thread）的方法，调用会暂停此线程指定的时间，但监控依然保持，不会释放对象锁，到时间自动恢复；wait()是Object的方法，调用会放弃对象锁，进入等待队列，待调用notify()或notifyAll()唤醒指定的线程或者所有线程


**wait(long timeout)：**  当前线程处于“等待状态”，当满足以下任意一个条件，当前线程被唤醒，重新进入锁池抢占同步资源锁

* 其他线程调用此对象的notify()方法，且线程 T，正好被选中唤醒
* 其它线程调用此对象的 notifyAll() 方法
* 其它线程中断线程T
* 超过指定的时间值，



```
代码：proof.chapter1.TestWaitTimeout

结果：

3，thread1 start...
1005，thread2 start...
7009，thread2 sleep 6000...
7012，thread1 is  over!

```

增加线程中断机制

```
代码：proof.chapter1.TestWaitTimeoutAndInterrupt

结果：

3，thread1 start...
1010，thread2 start...
3014，thread1 is  over!
java.lang.InterruptedException: sleep interrupted
	at java.lang.Thread.sleep(Native Method)
	at proof.chapter1.TestWaitTimeoutAndInterrupt$Task2.run(TestWaitTimeout.java:55)
	at java.lang.Thread.run(Thread.java:745)

Process finished with e

```

### 实战案例1

jasmine采用客户端主动拉取方式，感知配置项的动态变化。如果没有变列，当前请求会wait 10秒，如果这期间有变化，会立即响应。大概原理：

* 判断配置是否有变化的标准：key1=version2,key2=version2，比较这个串值有没有变化
* 以project name 创建 synchronized 锁，采用wait(10s)，并将锁Object放入Map中
* 如果这期间该project的配置项有变更，更新完自有存储后，调用锁Object的notifyAll(），唤醒之前等待的线程，抢占锁，然后返回响应。

参考：https://github.com/aalansehaiyang/knowledge-geek/blob/master/file/message-queue/8.md


### 实战案例2

                 
